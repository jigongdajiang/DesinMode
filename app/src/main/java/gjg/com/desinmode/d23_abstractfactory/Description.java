package gjg.com.desinmode.d23_abstractfactory;

/**
 * @author : gongdaocai
 * @date : 2017/7/21
 * FileName:
 * @description: 抽象工厂模式
 */


public class Description {
    /**
     * 定义:
     *      可以向客户端提供一个接口，使得客户端不必指定产品具体类型的情况下，创建多个产品族中的产品。
     *      抽象工厂通常创建的是一族产品，并且这族产品分布同的等级;不同的具体工厂类生产不同等级的一族产品
     * 场景:
     *      抽象工厂面对的是多产品等级结构的系统设计
     *      产品族:不同产品等级结构中，功能相关联的产品组  如 CPU+主板+硬盘+内存
     *      产品等级:多个产品族同级别的产品组  如 A的CPU  B的CPU  C的CPU
     * 角色:
     *      抽象工厂
     *      具体工厂
     *      抽象产品
     *      具体产品
     * 案例:
     *      见example
     * Android:
     *
     * 利弊:
     *      利:
     *          1、抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建；
     *          2、容易改变产品的系列；
     *          3、增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。
     *          4、将一个系列的产品族统一到一起创建，客户代码易于使用。
     *      弊:
     *           抽象工厂模式的最大缺点就是产品族扩展非常困难，为什么这么说呢？我们以通用代码为例，
     *           如果要增加一个产品 C， 也就是说产品家族由原来的 2 个增加到 3 个，看看我们的程序
     *           有多大改动吧！抽象类 AbstractCreator 要增加一个方法 createProductC()， 然
     *           后两个实现类都要修改，想想看，这严重违反了开闭原则，而且我们一直说明抽象类和接口是一个契约。
     */
}
