package gjg.com.desinmode.d16_mediator;

/**
 * @author : gongdaocai
 * @date : 2017/7/20
 * FileName:
 * @description: 调停者/中介者模式
 */


public class Description {
    /**
     *  定义:
     *      调停者模式封装了一系列对象相互作用的方式，使得这些对象不必交互的那么明显。将对象间多对多转换为一对多。
     *  场景:
     *      当对象间的交互较多，且每个对象的操作都依赖于彼此时
     *  角色:
     *      抽象调停者角色(AbstractMediator):定义出同事对象到调停者的接口
     *      具体调停者角色(ConcreteMediator):从具体的同事对象接受消息，向具体的同事对象发送命令
     *      抽象同事类(Colleague):定义同事的抽象接口,它只知道调停者，而不知道其它同事对象
     *      具体同事类s(ConcreteColleague):只知道本身小范围的行为，而不知道在大范围的目的
     *  案例:
     *      使用电脑来看电影
     　　    在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程：
     　　   （1）首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。
     　　   （2）主板去得到光驱的数据，把这些数据交给CPU进行分析处理。
     　　   （3）CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。
     　　   （4）主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音。
     　　    要使用调停者模式来实现示例，那就要区分出同事对象和调停者对象。很明显，主板是调停者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。
     *  android:
     *      EventBus
     *  利弊:
     *      利:松耦合，集中交互，多对多变为一对多
     *      弊:如果同事对象交互繁多，会导致调停者负载较重。
     */
}
